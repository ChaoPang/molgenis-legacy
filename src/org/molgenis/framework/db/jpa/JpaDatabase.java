package org.molgenis.framework.db.jpa;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import javax.persistence.EntityManager;
import javax.persistence.criteria.Expression;
import javax.persistence.metamodel.EntityType;

import org.molgenis.framework.db.Database;
import org.molgenis.framework.db.DatabaseException;
import org.molgenis.framework.db.JoinQuery;
import org.molgenis.framework.db.Query;
import org.molgenis.framework.db.QueryImp;
import org.molgenis.framework.db.QueryRule;
import org.molgenis.framework.db.CsvToDatabase.IntegerWrapper;
import org.molgenis.framework.security.Login;
import org.molgenis.model.elements.Model;
import org.molgenis.util.CsvReader;
import org.molgenis.util.CsvReaderListener;
import org.molgenis.util.CsvWriter;
import org.molgenis.util.Entity;
import org.molgenis.util.Tuple;

/**
 * Java Persistence API (JPA) implementation of Database to query relational databases.
 * <p>
 * In order to function, {@link org.molgenis.assets.data.jdbc_old.JpaMapper}
 * must be added for each {@link org.molgenis.assets.data.Entity} E that can be
 * queried. These mappers take care of the interaction with a database. Typically,
 * these mappers are generated by subclassing JDBCDatabase:
 * 
 * <pre>
 * public JDBCDatabase(DataSource data_src, File file_src) throws DatabaseException
 * {
 * 	super(data_src, file_src);
 * 	this.putMapper(Experiment.class, new ExperimentMapper());
 * 	this.putMapper(Assay.class, new AssayMapper());
 * 	this.putMapper(Data.class, new DataMapper());
 * 	this.putMapper(Protocol.class, new ProtocolMapper());
 * 	this.putMapper(Item.class, new ItemMapper());
 * 	this.putMapper(Subject.class, new SubjectMapper());
 * }
 * </pre>
 * 
 * @author Morris Swertz
 * @author Joris Lops
 */
public class JpaDatabase extends AbstractDatabase implements Database
{
	/** BATCH SIZE */
	private int BATCH_SIZE = 10000;

	private static Map<String, JpaMapper> mappers = new TreeMap<String, JpaMapper>();
	private EntityManager em = null;
	/** in transaction */
	private boolean inTransaction;
	/** login */
	private Login login;

	private Model model;
	
	public JpaDatabase(EntityManager em, Model jdbcMetaDatabase)
	{
		this.em = em;
		this.model = jdbcMetaDatabase;
	}
	
	protected JpaDatabase(Model jdbcMetaDatabase) {
		this.model = jdbcMetaDatabase;
	}
	
	protected void setEntityManager(EntityManager em) {
		this.em = em;
	}	
	
	public EntityManager getEntityManager() {
		return em;
	}



	@Override
	public <E extends Entity> int add(E entity) throws DatabaseException
	{
		try
		{
			if (!inTransaction) em.getTransaction().begin();

			List<Entity> entities = new ArrayList<Entity>();
			entities.add(entity);
			getMapper(entity.getClass().getName()).add(entities, em);

			if (!inTransaction) em.getTransaction().commit();
		}
		catch (javax.persistence.PersistenceException e)
		{
			//logger.error(e.getClass());
			//e.printStackTrace();
			throw new DatabaseException(e.getCause().getMessage());
		}
		logger.debug("added 1 " + entity.getClass());
		return 1;
	}

	@Override
	public <E extends Entity> int add(List<E> entities) throws DatabaseException, IOException
	{
		if (!inTransaction) {
			em.getTransaction().begin();
		}

		try
		{
			if(entities != null && entities.size() > 0) {
				getMapper(entities.get(0).getClass().getName()).add((List<Entity>)entities, em);
				em.flush();
			}
		}
		catch (Exception e)
		{
			if (!inTransaction) {
				em.getTransaction().rollback();
			}
			throw new DatabaseException(e);
		}
		if (!inTransaction) {
			em.getTransaction().commit();
		}
		return entities.size();
	}

	@Override
	public <E extends Entity> int add(final Class<E> klazz, final CsvReader reader, final CsvWriter writer)
			throws Exception
	{
		if (!inTransaction) {
			em.getTransaction().begin();
		}

		// batch of entities
		final List<E> entityBatch = new ArrayList<E>();
		// counter
		final IntegerWrapper count = new IntegerWrapper(0);

		try
		{
			reader.parse(new CsvReaderListener()
			{
				@Override
				public void handleLine(int lineNumber, Tuple tuple) throws Exception
				{
					E e = klazz.newInstance();
					e.set(tuple);
					entityBatch.add(e);

					if (entityBatch.size() > BATCH_SIZE)
					{
						for (E entity : entityBatch)
							em.persist(entity);

						count.set(count.get() + 1);
						em.flush();

						for (E entity : entityBatch)
							writer.writeRow(entity);

					}
				}
			});
		}
		catch (Exception e)
		{
			if (!inTransaction) em.getTransaction().rollback();
			throw new DatabaseException(e);
		}

		if (!inTransaction) em.getTransaction().commit();

		return count.get();
	}

	@Override
	public void beginTx() throws DatabaseException
	{
		try
		{
			inTransaction = true;
			em.getTransaction().begin();			
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
	}

	@Override
	public void close() throws DatabaseException
	{
		em.close();
	}

	@Override
	public void commitTx() throws DatabaseException
	{
		try
		{
			inTransaction = false;
			em.getTransaction().commit();
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
	}

	@Override
	public <E extends Entity> int count(Class<E> entityClass, QueryRule... rules) throws DatabaseException
	{
           return JPAQueryGeneratorUtil.createCountQuery(this, entityClass, rules);
	}

	@Override
	public <E extends Entity> void find(Class<E> entityClass, CsvWriter writer, QueryRule... rules)
			throws DatabaseException
	{
		try
		{
			throw new NoSuchMethodException();
		}
		catch (NoSuchMethodException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
//		List<E> result = JPAQueryGeneratorUtil.createWhere(entityClass, getMapper(entityClass.getName()), em, rules).getResultList();
	}

	@Override
	public <E extends Entity> void find(Class<E> entityClass, CsvWriter writer, List<String> fieldsToExport,
			QueryRule... rules) throws DatabaseException
	{
		boolean first = true;
		int count = 0;
		for (Entity e : find(entityClass, rules))
		{
			if (first)
			{
				writer.setHeaders(fieldsToExport);
				writer.writeHeader();
				first = false;
			}
			writer.writeRow(e);
			count++;
		}
		logger.debug(String.format("find(%s, writer) wrote %s lines", entityClass.getSimpleName(), count));
	}

	@Override
	public <E extends Entity> List<E> find(Class<E> entityClass, QueryRule... rules) throws DatabaseException
	{
    	return JPAQueryGeneratorUtil.createQuery(this, entityClass, rules);
	}

	@Override
	public <E extends Entity> E findById(Class<E> entityClass, Object id) throws DatabaseException
	{
		try
		{
			List<E> result = this.query(entityClass).eq(entityClass.newInstance().getIdField(), id).find();
			if (result.size() == 1) return result.get(0);
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
		return null;
	}

	@Override
	public Class<Entity> getClassForName(String simpleName)
	{
		for (Class<Entity> c : getEntityClasses())
		{
			if (c.getSimpleName().equalsIgnoreCase(simpleName))
			{
				return c;
			}
		}
		return null;
	}

	@Override
	public List<Class> getEntityClasses()
	{
		List<Class> result = new ArrayList<Class>();
		for (EntityType t : em.getMetamodel().getEntities())
		{
			result.add(t.getJavaType());
		}
		return result;
	}

	@Override
	public List<String> getEntityNames()
	{
		List<String> result = new ArrayList<String>();
		for (Class c : this.getEntityClasses())
		{
			result.add(c.getName());
		}
		return result;
	}

	@Override
	public File getFilesource()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public Model getMetaData() throws DatabaseException
	{
		return model;
	}

	@Override
	public Login getSecurity()
	{
		return login;
	}

	@Override
	public boolean inTx()
	{
		return inTransaction;
	}

	@Override
	public <E extends Entity> Query<E> query(Class<E> entityClass)
	{
		return new QueryImp<E>(this, entityClass);
	}

	@Override
	public JoinQuery query(List<String> fields) throws DatabaseException
	{
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <E extends Entity> int remove(E entity) throws DatabaseException, IOException
	{
		if (!inTransaction) em.getTransaction().begin();
		try
		{
			Entity entityToRemove = em.find(entity.getClass(), entity.getIdValue());
			em.remove(entityToRemove);
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
		if (!inTransaction) em.getTransaction().commit();
		return 1;
	}

	@Override
	public <E extends Entity> int remove(List<E> entities) throws DatabaseException, IOException
	{
		if (!inTransaction) em.getTransaction().begin();
		try
		{
			for (E entity : entities)
				em.remove(entity);
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
		if (!inTransaction) em.getTransaction().commit();
		return 1;
	}

	@Override
	public <E extends Entity> int remove(final Class<E> entityClass, final CsvReader reader) throws DatabaseException,
			IOException, Exception
	{
		if (!inTransaction) em.getTransaction().begin();

		// batch of entities
		final List<E> entityBatch = new ArrayList<E>();
		// counter
		final IntegerWrapper count = new IntegerWrapper(0);

		try
		{

			reader.parse(new CsvReaderListener()
			{

				@Override
				public void handleLine(int lineNumber, Tuple tuple) throws Exception
				{
					E e = entityClass.newInstance();
					e.set(tuple);
					entityBatch.add(e);

					if (entityBatch.size() > BATCH_SIZE)
					{
						for (E entity : entityBatch)
							em.remove(e);

						count.set(count.get() + 1);
						em.flush();
					}
				}
			});
		}
		catch (Exception e)
		{
			if (!inTransaction) em.getTransaction().rollback();
			throw new DatabaseException(e);
		}

		if (!inTransaction) em.getTransaction().commit();

		return count.get();

	}

	@Override
	public void rollbackTx() throws DatabaseException
	{
		try
		{
			em.getTransaction().rollback();
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}

	}

	@Override
	public void setLogin(Login login)
	{
		this.login = login;
	}

	@Override
	public <E extends Entity> List<E> toList(Class<E> klazz, CsvReader reader, int noEntities) throws Exception
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public <E extends Entity> int update(E entity) throws DatabaseException, IOException
	{
		if (!inTransaction) em.getTransaction().begin();
		try
		{
			Entity entityToMerge = em.find(entity.getClass(), entity.getIdValue());
			em.merge(entityToMerge);
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
		if (!inTransaction) em.getTransaction().commit();
		return 1;
	}

	@Override
	public <E extends Entity> int update(List<E> entities) throws DatabaseException, IOException
	{
		if (!inTransaction) em.getTransaction().begin();
		try
		{
			for (E entity : entities) {
				Entity entityToMerge = em.find(entity.getClass(), entity.getIdValue());
				em.merge(entityToMerge);
			}
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
		if (!inTransaction) em.getTransaction().commit();
		return 1;
	}

	@Override
	public <E extends Entity> int update(final Class<E> entityClass, final CsvReader reader) throws DatabaseException,
			IOException, Exception
	{
		if (!inTransaction) em.getTransaction().begin();

		// batch of entities
		final List<E> entityBatch = new ArrayList<E>();
		// counter
		final IntegerWrapper count = new IntegerWrapper(0);

		try
		{

			reader.parse(new CsvReaderListener()
			{

				@Override
				public void handleLine(int lineNumber, Tuple tuple) throws Exception
				{
					E e = entityClass.newInstance();
					e.set(tuple);
					entityBatch.add(e);

					if (entityBatch.size() > BATCH_SIZE)
					{
						for (E entity : entityBatch)
							em.merge(entity);

						count.set(count.get() + 1);
						em.flush();
					}
				}
			});
		}
		catch (Exception e)
		{
			if (!inTransaction) em.getTransaction().rollback();
			throw new DatabaseException(e);
		}

		if (!inTransaction) em.getTransaction().commit();

		return count.get();

	}

	protected static <E extends Entity> void putMapper(Class<E> klazz, JpaMapper<E> mapper)
	{		
		mappers.put(klazz.getName(), mapper);
		// logger.debug("added mapper for klazz " + klazz.getName());
	}
	
	protected <E extends Entity> JpaMapper<E> getMapper(String name) {
		return mappers.get(name);
	}
	
	private Expression<Boolean> queryRuleToCriteria(QueryRule[] rules)
	{
		return null;
		//return JPAQueryGeneratorUtil.createWhere(this.getClass(), this, em, rules);
	}
	
	public void flush()
	{
		em.flush();
	}
	
	public List executeSQLQuery(String sqlQuery) {
		return em.createNativeQuery(sqlQuery).getResultList();
	}	
}
