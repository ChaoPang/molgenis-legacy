package org.molgenis.framework.db.jpa;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import javax.persistence.EntityManager;
import javax.persistence.criteria.Expression;
import javax.persistence.metamodel.EntityType;

import org.molgenis.framework.db.Database;
import org.molgenis.framework.db.DatabaseException;
import org.molgenis.framework.db.JoinQuery;
import org.molgenis.framework.db.Mapper;
import org.molgenis.framework.db.Query;
import org.molgenis.framework.db.QueryImp;
import org.molgenis.framework.db.QueryRule;
import org.molgenis.framework.db.CsvToDatabase.IntegerWrapper;
import org.molgenis.framework.security.Login;
import org.molgenis.model.elements.Model;
import org.molgenis.util.CsvReader;
import org.molgenis.util.CsvReaderListener;
import org.molgenis.util.CsvWriter;
import org.molgenis.util.Entity;
import org.molgenis.util.Tuple;

import sun.font.LayoutPathImpl.EndType;

/**
 * Java Persistence API (JPA) implementation of Database to query relational databases.
 * <p>
 * In order to function, {@link org.molgenis.assets.data.jdbc_old.JpaMapper}
 * must be added for each {@link org.molgenis.assets.data.Entity} E that can be
 * queried. These mappers take care of the interaction with a database. Typically,
 * these mappers are generated by subclassing JDBCDatabase:
 * 
 * <pre>
 * public JDBCDatabase(DataSource data_src, File file_src) throws DatabaseException
 * {
 * 	super(data_src, file_src);
 * 	this.putMapper(Experiment.class, new ExperimentMapper());
 * 	this.putMapper(Assay.class, new AssayMapper());
 * 	this.putMapper(Data.class, new DataMapper());
 * 	this.putMapper(Protocol.class, new ProtocolMapper());
 * 	this.putMapper(Item.class, new ItemMapper());
 * 	this.putMapper(Subject.class, new SubjectMapper());
 * }
 * </pre>
 * 
 * @author Morris Swertz
 * @author Joris Lops
 */
public class JpaDatabase extends AbstractDatabase implements Database
{
	/** BATCH SIZE */
	private int BATCH_SIZE = 10000;

	private static Map<String, JpaMapper> mappers = new TreeMap<String, JpaMapper>();
	private EntityManager em = null;
	/** in transaction */
	//private boolean inTransaction;
	/** login */
	private Login login;

	private Model model;
	
	public JpaDatabase(EntityManager em, Model jdbcMetaDatabase)
	{
		this.em = em;
		this.model = jdbcMetaDatabase;
	}
	
	protected JpaDatabase(Model jdbcMetaDatabase) {
		this.model = jdbcMetaDatabase;
	}
	
	protected void setEntityManager(EntityManager em) {
		this.em = em;
	}	
	
	public EntityManager getEntityManager() {
		return em;
	}



	@Override
	public <E extends Entity> int add(E entity) throws DatabaseException
	{
		int count = -1;
		try
		{
			beginTransaction();
				List<Entity> entities = new ArrayList<Entity>();
				entities.add(entity);
				count = add(entities);
			commitTransaction();
		}
		catch (javax.persistence.PersistenceException e)
		{
			rollbackTx();
			throw new DatabaseException(e.getCause().getMessage());
		}
		return count;
	}

	@Override
	public <E extends Entity> int add(List<E> entities) throws DatabaseException
	{
		int count = -1;
		try
		{
			beginTransaction();
				if(entities != null && entities.size() > 0) {
					count = getMapper(entities.get(0).getClass().getName()).add((List<Entity>)entities, em);
				}
			commitTransaction();
		}
		catch (Exception e)
		{
			rollbackTx();
			throw new DatabaseException(e);
		}

		return count;
	}

	@Override
	public <E extends Entity> int add(final Class<E> klazz, final CsvReader reader, final CsvWriter writer)
			throws Exception
	{
		// batch of entities
		final List<E> entityBatch = new ArrayList<E>();
		// counter
		final IntegerWrapper count = new IntegerWrapper(0);

		try
		{
			beginTransaction();
				reader.parse(new CsvReaderListener()
				{
					@Override
					public void handleLine(int lineNumber, Tuple tuple) throws Exception
					{
						E e = klazz.newInstance();
						e.set(tuple);
						entityBatch.add(e);
	
						if (entityBatch.size() > BATCH_SIZE)
						{
							for (E entity : entityBatch)
								em.persist(entity);
	
							count.set(count.get() + 1);
							em.flush();
	
							for (E entity : entityBatch)
								writer.writeRow(entity);
	
						}
					}
				});			
			commitTransaction();			
		}
		catch (Exception e)
		{
			rollbackTx();
			throw new DatabaseException(e);
		}

		return count.get();
	}
	
	private void beginTransaction() throws DatabaseException
	{
		if (!inTx()) {
			beginTx();
		}					
	}
	
	private void commitTransaction() throws DatabaseException 
	{
		if (inTx()) {
			commitTx();
		}
	}
	

	@Override
	public void beginTx() throws DatabaseException
	{
		try {
			if(em.getTransaction() != null && !em.getTransaction().isActive()) {
				em.getTransaction().begin();
			}
		} catch (Exception e) {
			throw new DatabaseException(e);
		}
	}

	@Override
	public void close() throws DatabaseException
	{ 
		try {
			em.close();
		} catch (Exception e) {
			throw new DatabaseException(e);
		}
	}

	@Override
	public void commitTx() throws DatabaseException
	{
		try
		{
			if(em.getTransaction() != null && em.getTransaction().isActive()) {
				em.getTransaction().commit();
			}
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
	}

	@Override
	public <E extends Entity> int count(Class<E> entityClass, QueryRule... rules) throws DatabaseException
	{
           return JPAQueryGeneratorUtil.createCountQuery(this, entityClass, rules);
	}

	@Override
	public <E extends Entity> void find(Class<E> entityClass, CsvWriter writer, QueryRule... rules)
			throws DatabaseException
	{
		try
		{
			throw new NoSuchMethodException();
		}
		catch (NoSuchMethodException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
//		List<E> result = JPAQueryGeneratorUtil.createWhere(entityClass, getMapper(entityClass.getName()), em, rules).getResultList();
	}

	@Override
	public <E extends Entity> void find(Class<E> entityClass, CsvWriter writer, List<String> fieldsToExport,
			QueryRule... rules) throws DatabaseException
	{
		boolean first = true;
		int count = 0;
		for (Entity e : find(entityClass, rules))
		{
			if (first)
			{
				writer.setHeaders(fieldsToExport);
				writer.writeHeader();
				first = false;
			}
			writer.writeRow(e);
			count++;
		}
		logger.debug(String.format("find(%s, writer) wrote %s lines", entityClass.getSimpleName(), count));
	}

	@Override
	public <E extends Entity> List<E> find(Class<E> entityClass, QueryRule... rules) throws DatabaseException
	{
    	return JPAQueryGeneratorUtil.createQuery(this, entityClass, rules);
	}

	@Override
	public <E extends Entity> E findById(Class<E> entityClass, Object id) throws DatabaseException
	{
		try
		{
			List<E> result = this.query(entityClass).eq(entityClass.newInstance().getIdField(), id).find();
			if (result.size() == 1) return result.get(0);
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}
		return null;
	}

	@Override
	public Class<Entity> getClassForName(String simpleName)
	{
		for (Class<Entity> c : getEntityClasses())
		{
			if (c.getSimpleName().equalsIgnoreCase(simpleName))
			{
				return c;
			}
		}
		return null;
	}

	@Override
	public List<Class> getEntityClasses()
	{
		List<Class> result = new ArrayList<Class>();
		for (EntityType t : em.getMetamodel().getEntities())
		{
			result.add(t.getJavaType());
		}
		return result;
	}

	@Override
	public List<String> getEntityNames()
	{
		List<String> result = new ArrayList<String>();
		for (Class c : this.getEntityClasses())
		{
			result.add(c.getName());
		}
		return result;
	}

	@Override
	public File getFilesource()
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public Model getMetaData() throws DatabaseException
	{
		return model;
	}

	@Override
	public Login getSecurity()
	{
		return login;
	}

	@Override
	public boolean inTx()
	{
		if(em.getTransaction() == null)
			return false;
		return em.getTransaction().isActive();
	}

	@Override
	public <E extends Entity> Query<E> query(Class<E> entityClass)
	{
		return new QueryImp<E>(this, entityClass);
	}

	@Override
	public JoinQuery query(List<String> fields) throws DatabaseException
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public <E extends Entity> int remove(E entity) throws DatabaseException
	{
		int count = -1;
		try
		{
			beginTransaction();
				List<Entity> entities = new ArrayList<Entity>();
				entities.add(entity);
				count = remove(entities);
			commitTransaction();
		}
		catch (Exception e)
		{
			rollbackTx();
			throw new DatabaseException(e);
		}
		return count;
	}

	@Override
	public <E extends Entity> int remove(List<E> entities) throws DatabaseException
	{
		int count = -1;
		try {
			beginTransaction();
				count = getMapper(entities.get(0).getClass().getName()).remove((List<Entity>)entities, em);
			commitTransaction();
		} catch (Exception e) {
			rollbackTx();
			throw new DatabaseException(e);
		}		
		return count;
	}

	@Override
	public <E extends Entity> int remove(final Class<E> entityClass, final CsvReader reader) throws DatabaseException
	{
		// batch of entities
		final List<E> entityBatch = new ArrayList<E>();
		// counter
		final IntegerWrapper count = new IntegerWrapper(0);

		try {
			beginTransaction();			
				reader.parse(new CsvReaderListener()
				{	
					@Override
					public void handleLine(int lineNumber, Tuple tuple) throws Exception
					{
						E e = entityClass.newInstance();
						e.set(tuple);
						entityBatch.add(e);
	
						if (entityBatch.size() > BATCH_SIZE)
						{
							for (E entity : entityBatch)
								em.remove(e);
	
							count.set(count.get() + 1);
							em.flush();
						}
					}
				});
			commitTransaction();
		} catch (Exception e) {
			rollbackTx();
			throw new DatabaseException(e);
		}
		return count.get();
	}

	@Override
	public void rollbackTx() throws DatabaseException
	{
		try
		{
			if(em.getTransaction().isActive()) {
				em.getTransaction().rollback();
			}
		}
		catch (Exception e)
		{
			throw new DatabaseException(e);
		}

	}

	@Override
	public void setLogin(Login login)
	{
		this.login = login;
	}

	@Override
	public <E extends Entity> List<E> toList(Class<E> klazz, CsvReader reader, int noEntities) throws Exception
	{
		throw new UnsupportedOperationException();
	}

	@Override
	public <E extends Entity> int update(E entity) throws DatabaseException, IOException
	{
		int count = -1;
		try
		{
			beginTransaction();
			
			List<Entity> entities = new ArrayList<Entity>();
			entities.add(entity);
			count = update(entities);
			
			commitTransaction();
		}
		catch (Exception e)
		{
			rollbackTx();
			throw new DatabaseException(e);
		}		
		return count;
	}

	@Override
	public <E extends Entity> int update(List<E> entities) throws DatabaseException, IOException
	{
		try
		{
			beginTransaction();
				getMapper(entities.get(0).getClass().getName()).update((List<Entity>)entities, em);
			commitTransaction();
		}
		catch (Exception e)
		{
			rollbackTx();
			throw new DatabaseException(e);
		}
		
		return 1;
	}

	@Override
	public <E extends Entity> int update(final Class<E> entityClass, final CsvReader reader) throws DatabaseException,
			IOException, Exception
	{
		// batch of entities
		final List<E> entityBatch = new ArrayList<E>();
		// counter
		final IntegerWrapper count = new IntegerWrapper(0);

		try
		{
			beginTransaction();
			reader.parse(new CsvReaderListener()
			{

				@Override
				public void handleLine(int lineNumber, Tuple tuple) throws Exception
				{
					E e = entityClass.newInstance();
					e.set(tuple);
					entityBatch.add(e);

					if (entityBatch.size() > BATCH_SIZE)
					{
						for (E entity : entityBatch)
							em.merge(entity);

						count.set(count.get() + 1);
						em.flush();
					}
				}
			});
			commitTransaction();
		}
		catch (Exception e)
		{
			rollbackTx();
			throw new DatabaseException(e);
		}
		return count.get();

	}

	protected static <E extends Entity> void putMapper(Class<E> klazz, JpaMapper<E> mapper)
	{		
		mappers.put(klazz.getName(), mapper);
		// logger.debug("added mapper for klazz " + klazz.getName());
	}
	
	protected <E extends Entity> JpaMapper<E> getMapper(String name) {
		return mappers.get(name);
	}
	
	public void flush()
	{
		em.flush();
	}
	
	public List executeSQLQuery(String sqlQuery) {
		return em.createNativeQuery(sqlQuery).getResultList();
	}	
}
